from django.shortcuts import render, redirectfrom django.http import HttpResponsefrom django.utils import timezonefrom django.db import connectionfrom .forms import CQHEISurveyFormfrom .models import CQHEISurveyimport csv# helper to normalize checkbox ‚Üí scoredef score(val):    return 2 if val else 0def survey_form(request):    if request.method == 'POST':        print("üî•üî•üî• SURVEY POST HIT UPDATED DJANGO CODE üî•üî•üî•")        form = CQHEISurveyForm(request.POST)        if form.is_valid():            # Save main survey            survey = form.save()            print(f"üî• SURVEY SAVED ‚Äî ID = {survey.id}")            # ============================            # Section II ‚Äì Fish Cover            # ============================            now = timezone.now()            with connection.cursor() as cursor:                cursor.execute(                    """                    INSERT INTO cQHEI.Cover (                        cQHEI_New_X_ID,                        Underwater_Tree_Roots,                        Underwater_Tree_Rootlets,                        Boulders,                        Oxbows_Backwaters,                        Downed_trees,                        Shallows,                        Water_Plants,                        Deep_Pools,                        Overhanging_Vegetation,                        Undercut_Banks,                        Created_Timestamp,                        Last_Updated_Timestamp                    )                    OUTPUT INSERTED.Cover_Score                    VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)                    """,                    [                        survey.id,                        score(form.cleaned_data.get('cover_underwater_tree_roots_large')),                        score(form.cleaned_data.get('cover_underwater_tree_rootlets')),                        score(form.cleaned_data.get('cover_boulders')),                        score(form.cleaned_data.get('cover_backwaters')),                        score(form.cleaned_data.get('cover_downed_trees')),                        score(form.cleaned_data.get('cover_shallow_slow_areas')),                        score(form.cleaned_data.get('cover_water_plants')),                        score(form.cleaned_data.get('cover_deep_areas')),                        score(form.cleaned_data.get('cover_shrubs_small_trees')),                        score(form.cleaned_data.get('cover_undercut_banks')),                        now,                        now                    ]                )                section2_score = cursor.fetchone()[0]            print(f"üî• COVER SCORE RETURNED FROM SQL = {section2_score}")            # Persist computed Cover_Score onto survey            survey.cover_score = section2_score            survey.save(update_fields=["cover_score"])            print(                f"üî• COVER SCORE SAVED ON SURVEY {survey.id} = {survey.cover_score}"            )            return redirect('survey_success', survey_id=survey.id)        else:            print("‚ùå FORM INVALID")            print(form.errors)    else:        form = CQHEISurveyForm()    return render(        request,        'survey_form.html',        {            'form': form        }    )def survey_success(request, survey_id):    try:        survey = CQHEISurvey.objects.get(id=survey_id)        return render(request, 'success.html', {'survey': survey})    except CQHEISurvey.DoesNotExist:        return HttpResponse("Survey not found")def survey_list(request):    surveys = CQHEISurvey.objects.all().order_by('-survey_date')    return render(request, 'survey_list.html', {'surveys': surveys})def export_surveys_csv(request):    response = HttpResponse(content_type='text/csv')    response['Content-Disposition'] = 'attachment; filename="cqhei_surveys.csv"'    writer = csv.writer(response)    writer.writerow(['ID', 'Date', 'River Site', 'River Code', 'River Mile', 'Name/Group'])    surveys = CQHEISurvey.objects.all().order_by('-survey_date')    for survey in surveys:        writer.writerow([            survey.id,            survey.survey_date,            survey.river_site,            survey.river_code,            survey.river_mile,            survey.name_group        ])    return response